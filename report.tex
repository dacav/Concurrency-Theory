\documentclass[10pt,a4paper]{article}
%\documentclass[10pt,twocolumn,a4paper]{article}

\usepackage{amsmath, amssymb, braket}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{a4wide}
\usepackage[lined]{algorithm2e}
\usepackage{parcolumns}
\usepackage{mathpazo}

\usepackage[colorlinks,
            pdftex,
            bookmarks=true]{hyperref}
\hypersetup{
    pdfauthor = {Giovanni Simoni}
    pdftitle = {Concurrency Theory Project}
    pdfsubject = {},
    pdfkeywords = {CCS, Concurrency Workbench}
    pdfcreator = {LaTeX with hyperref package},
    pdfproducer = {pdflatex}
}

\newcommand{\Note}[1]{\paragraph{Note:}{#1}}

\newcommand{\CCS}{{\tt CCS}}
\newcommand{\CCSCode}[1]{{\tt #1}}

\newcommand{\Agent}[1]{{\tt {#1}}}
\newcommand{\Action}[1]{{\tt \bf {#1}}}
\newcommand{\CoAction}[1]{$\overline{\mbox{\Action{#1}}}$}

\newcommand{\FileName}[1]{{\sf {#1}}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex}

\title {
    Concurrency Theory Project
}
\author{
    Giovanni Simoni\\
    Register 142955\\
    \href{mailto:giovanni.simoni@roundhousecode.com}
         {giovanni.simoni@roundhousecode.com}
}

\begin{document}

\maketitle

\section{Introduction}
\label{sec:Intro}

    I chose to implement the first project, namely the \emph{Dekker
    protocol} for mutual exclusion.

    My implementation aims to be as modular as possible by using the
    parametrization of \CCS{} entities extensively.

    The technique consists in defining abstract behaviors trough agents
    whose actions are binded by formal parameters. Instantiation of an
    abstract behavior into a concrete process consists in the definition
    of a new agent, which behaves as the abstract one but provides, as
    actual parameters, actions which allow interaction with other
    processes.

\section{The protocol}

    The implementation encodes two abstract behaviors:

    \begin{itemize}

    \item   The read/write behavior of boolean variables, which values can
            be read or re-assigned by means of actions;

    \item   The sequence of actions specified by the Dekker
            protocol.

    \end{itemize}

    \subsection{Encoding of the boolean variable abstraction}
    \label{sub:EncodeBool}

        This abstraction consists in a simple process \Agent{Bool} which
        models the behavior of a boolean variable setted to False. It can
        be queried with a \CoAction{get} action (the \Action{false} action
        will be produced) or setted to True by a \CoAction{set} action.

        When the variable is setted to True the same behavior is adopted
        with inverted logic so that a \CoAction{unset} action restores the
        previous behavior.

        \begin{verbatim}
    agent Bool (true, false, get, set, unset)
        = 'set.Bool(false, true, get, unset, set)
        + 'get.false.Bool(true, false, get, set, unset)
        ;
        \end{verbatim}

        Picture~\ref{pic:Bool} shows a graphical representation of the
        unwound boolean abstraction.

    \subsection{Encoding of the Dekker protocol abstraction}

        \subsubsection{Branching points}
        \label{subsub:BranchingPoints}

            In order to encode the protocol I simply considered the
            \emph{branching points} of the given algorithmic version of
            the protocol and converted them into \CCS{} \emph{choice
            operators}.

            \noindent For instance, an \emph{if-then-else} block like
            \begin{quote}
                \begin{algorithm}[H]
                \eIf{$x$}{
                    $y$ $\leftarrow$ true;
                }{
                    $y$ $\leftarrow$ false;
                }
                \end{algorithm}
            \end{quote}
            can be represented as
            \begin{quote}
            \CCSCode{getx.('truex,.sety + 'falsex.unsety)}
            \end{quote}
            where
            \begin{itemize}

            \item   \CCSCode{getx} is the output action querying for the
                    value of $x$;

            \item   \CCSCode{'truex} and \CCSCode{'falsex} are the input
                    actions required to read respectively \emph{true} or
                    \emph{false} as result of the \CCSCode{getx} query;

            \item   \CCSCode{sety} and \CCSCode{unsety} are the output
                    actions used respectively to set to \emph{true} or
                    \emph{false} the $y$ variable.

            \end{itemize}

        \subsubsection{The actual code}
        \label{subsub:ActualCode}

            The protocol requires two boolean variables $b_i$ and $b_j$
            for critical access requests plus an integer variable $k$
            representing the turn. Since however $k$ can take values in
            $\Set{0, 1}$, I considered it as it were a boolean variable as
            well, provided that one of the two processes following the
            protocol accesses $k$ with a negated logic.

            I adopted the same conventions of the provided algorithm for
            process naming: the abstraction uses the $i$ index to name the
            process itself and $j$ index to name the other process. More
            on this topic in Section~\ref{sec:Instantiation}.

            For convenience the protocol has been split into four
            processes:
            \begin{itemize}
            \item   The first one (\Agent{Proc}) is the starting point of
                    the protocol's main loop;
            \item   The others (\Agent{Proc1}, \Agent{Proc2} and
                    \Agent{Proc3}) are mapped on the three branching point
                    of the algorithm, thus they work as explained in
                    Paragraph~\ref{subsub:BranchingPoints}.
            \end{itemize}

            Finally the \emph{critical section} access is abstracted away
            (it's supposed to correspond to a sequence of $\tau$~actions),
            while the act of process $i$ exiting from it corresponds to
            the \CCSCode{exiti} action.

            So far, after all this explanations, here we have the \CCS{}
            code:
            \begin{verbatim}
    agent Proc = seti.Proc1;
    agent Proc1 = getj.( 'truej.Proc2 + 'falsej.exiti.unsetk.unseti.Proc0 );
    agent Proc2 = getk.( 'falsek.Proc1 + 'truek.unseti.Proc3 );
    agent Proc3 = getk.( 'falsek.Proc3 + 'truek.seti.Proc1 );
            \end{verbatim}

            Picture~\ref{pic:Dekker} shows a graphical representation of the
            Dekker protocol abstraction.

            \Note{
                In the delivered definition the agents the actual
                parametrized actions have been written into a short form
                for which:
                \begin{multicols}{2}
                    \begin{itemize}
                    \item   \CCSCode{geti} becomes \CCSCode{gi};
                    \item   \CCSCode{seti} becomes \CCSCode{si};
                    \item   \CCSCode{unseti} becomes \CCSCode{ui};
                    \item   \CCSCode{truei} becomes \CCSCode{ti};
                    \item   \CCSCode{falsei} becomes \CCSCode{fi};
                    \item   \CCSCode{exiti} becomes \CCSCode{xi};
                    \end{itemize}
                \end{multicols}
            }

    \begin{figure}[htbp]
        \centering
        \subfloat[Boolean variable process]{
            \label{pic:Bool}
            \includegraphics[width=.5\textwidth]{pics/bool}
        }
        \subfloat[Dekker process]{
            \label{pic:Dekker}
            \includegraphics[width=.5\linewidth]{pics/dekker}
        }
        \label{pic:Protocol}
        \caption{
            The graph of abstract behaviors. The right graph shows the
            encoding of a process implementing the Dekker protocol, while
            the left one shows the behavior of a process emulating a
            boolean variable.
        }
    \end{figure}

\section{Instantiation}
\label{sec:Instantiation}

    As we saw in Section~\ref{sec:Intro}, the instantiation consists in
    defining new agents which provide actual parameters to the abstract
    ones.

    \subsection{Boolean variable instantiation}

        We need to define three boolean variables: \Agent{B0},
        \Agent{B1} and \Agent{Bk}.

        Basing on the requirements and naming conventions explained in
        Paragraph~\ref{subsub:ActualCode}, the parametrization is such
        that actions produced by boolean variable $b_i$ have $i$ as
        suffix:
        \begin{verbatim}
    agent B0 = Bool (true0, false0, get0, set0, unset0);
    agent B1 = Bool (true1, false1, get1, set1, unset1);
        \end{verbatim}

        The same must hold for the $k$ variable, but here also we want to
        have a non-deterministic assignment of the variable:
        \begin{verbatim}
    agent Bk = Bool (truek, falsek, getk, unsetk, setk)
             + Bool (falsek, truek, getk, setk, unsetk);
        \end{verbatim}

    \subsection{Processes instantiation}

        Concerning processes, we need to define the two concurrent agents
        \Agent{P0} and \Agent{P1} which must behave accordingly to
        the logic defined till now:
        \begin{itemize}

        \item   The actions having the \CCSCode{i} suffix are referred to
                the process itself, thus for example \CCSCode{seti}
                becomes \CCSCode{set0} for \Agent{P0} and
                \CCSCode{set1} for \Agent{P1};

        \item   The actions having the \CCSCode{j} suffix are referred to
                the other process, thus for example \CCSCode{getj} becomes
                \CCSCode{get1} for \Agent{P0} and \CCSCode{get0} for
                \Agent{P1};

        \item   The $k$ variable behaves in negated mode for one of the two
                processes (we can arbitrarily choose \Agent{P1}):

            \begin{itemize}

            \item   The actions \CCSCode{setk} and \CCSCode{unsetk} are
                    swapped;
            \item   The actions \CCSCode{'truek} and \CCSCode{'falsek} are
                    swapped;

            \end{itemize}

        \end{itemize}

        Follows the code:
        \begin{verbatim}
    agent P0 = Proc(set0, get0, unset0,
                    set1, get1, unset1,
                    setk, getk, unsetk,
                    true0, false0,
                    true1, false1,
                    truek, falsek,
                    exit0);

    agent P1 = Proc(set1, get1, unset1,
                    set0, get0, unset0,
                    unsetk, getk, setk,
                    true1, false1,
                    true0, false0,
                    falsek, truek,
                    exit1);
        \end{verbatim}

\section{Final system}

    Now all ingredients for our recipe are ready. We just need to define
    the concurrent system, which is simply:
    \begin{verbatim}
    agent System = ( P0 | P1 | B0 | B1 | Bk ) \ S;
    \end{verbatim}
    where \CCSCode{S} is the set of actions behaviors we want to restrict
    in order to allow only synchronizations between the processes:
    \begin{verbatim}
    set S = {   s0, g0, u0, t0, f0,
            s1, g1, u1, t1, f1,
            sk, gk, uk, tk, fk
        };
    \end{verbatim}

\section{Model checking}

    \subsection{Safety}

    \subsection{Liveness}

    \subsection{Fairness}

\end{document}


